<!DOCTYPE HTML>
<html>
<head>
    <title>Google Map - Twitter</title>
    <style type="text/css">
        html, body { height: 100%; margin: 0; padding: 0; margin-top: 10px; }
        #map { height: 90%; width: 80%; margin: auto; }

        #locationField {
            height: 20px;
            margin-bottom: 2px;
        }

        #locationField, #controls {
            position: relative;
            width: 480px;
        }

        #autocomplete {
            position: absolute;
            top: 0px;
            left: 0px;
            width: 99%;
        }
    </style>
    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/socket.io/0.9.16/socket.io.min.js"></script>
    <script type="text/javascript" src="https://maps.google.com/maps/api/js?libraries=places"></script>
</head>
<body>
    <div id="locationField" style="margin:auto;">
        <input id="autocomplete" placeholder="Enter your address" type="text"></input>
        </div>
    <div id="map"></div>

<script>
    var namespace = '/tweets';

    $(function() {
        //var latlng = new google.maps.LatLng(38.8833, 77.0167);
        var latlng = {lat: 14.5833, lng: 120.984222};

        var myOptions = {
            zoom: 9,
            center: latlng,
            mapTypeId: google.maps.MapTypeId.ROADMAP
        };
    
        var map = new google.maps.Map(document.getElementById("map"), myOptions);
        __map = map;

        var infoWindow = new google.maps.InfoWindow({
            maxWidth: 200
        });

        var geocoder = new google.maps.Geocoder();

        var url = document.domain + ':' + location.port + namespace;
        var socket = io.connect(url);

        console.log(url);

        socket.on('tweet', function(data) {
            // console.log(data);

            if (data.coordinates !== null) {
                var loc1 = data.coordinates.coordinates[1];
                var loc0 = data.coordinates.coordinates[0];
                var myLatlang = new google.maps.LatLng(loc1, loc0);

                // console.log(loc1);
                // console.log(loc0);

                var marker = new google.maps.Marker({
                    position: myLatlang,
                    animation: google.maps.Animation.DROP,
                    map: map
                })  

                // Remove marker after 1m
                setTimeout(function() {
                    marker.setMap(null);
                    delete marker;
                }, 60000);


                google.maps.event.addListener(marker, 'mouseover', function() {
                    infoWindow.setContent("<img src='"+data.user.profile_image_url+"' style='float:left; padding: 5px;' /><strong>"+data.user.screen_name+"</strong>: "+data.text);
                    infoWindow.open(map, this);
                });
            }
        });

        autocomplete = new google.maps.places.Autocomplete(
        /** @type {!HTMLInputElement} */(document.getElementById('autocomplete')),
        {types: ['geocode']});

        // When the user selects an address from the dropdown, populate the address
        // fields in the form.
        autocomplete.addListener('place_changed', function(data, i) {
            var place = autocomplete.getPlace();

            console.log(place.formatted_address);

            if (!place.geometry) {
                window.alert("Autocomplete's returned place contains no geometry");
                return;
            } else if (place.geometry.viewport) {
                map.fitBounds(place.geometry.viewport);
                map.setZoom(9);
            } else {
                map.setCenter(place.geometry.location);
                map.setZoom(17);
            }

            geocoder.geocode({'address': place.formatted_address}, function(results, status) {
                if (status === google.maps.GeocoderStatus.OK) {
                    if (!results[0].geometry.bounds) {
                        alert('Location geometry bounds not found');
                    } else {
                        var bounds = results[0].geometry.bounds;
                        var boundsObj = {
                            'sw': {
                                'lng': bounds.j.j,
                                'lat': bounds.N.N
                            },
                            'ne': {
                                'lng': bounds.j.N,
                                'lat': bounds.N.j
                            }
                        };

                        console.log(boundsObj);

                        $.ajax({
                            type: 'POST',
                            contentType: 'application/json',
                            dataType: 'json',
                            url: '/change_location',
                            data: JSON.stringify(boundsObj),
                            success: function(data) {
                                console.log('server response');
                                console.log(data);
                            }
                        });
                    }
                } else {
                    alert('Geocode was not successful for the following reason: ' + status);
                }

            });
        });

        $('input').focus(function() {
            if (navigator.geolocation) { 
                navigator.geolocation.getCurrentPosition(function(position) {
                    var geolocation = {
                        lat: position.coords.latitude,
                        lng: position.coords.longitude
                    };

                    var circle = new google.maps.Circle({
                        center: geolocation,
                        radius: position.coords.accuracy
                    });
                    autocomplete.setBounds(circle.getBounds());
                });
            }
        });    
    });
</script>
</body>
</html>

